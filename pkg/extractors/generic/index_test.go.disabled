package generic

import (
	"strings"
	"testing"

	"github.com/PuerkitoBio/goquery"
)

// Test HTML samples for extraction testing
const (
	simpleArticleHTML = `
<!DOCTYPE html>
<html>
<head>
    <title>Test Article Title</title>
    <meta name="author" content="John Doe">
    <meta name="description" content="This is a test article description">
</head>
<body>
    <article>
        <h1>Test Article Title</h1>
        <p class="author">By John Doe</p>
        <p>This is the main content of the test article. It contains multiple paragraphs to test content extraction.</p>
        <p>This is the second paragraph with more content for testing purposes.</p>
    </article>
</body>
</html>`

	rtlArticleHTML = `
<!DOCTYPE html>
<html dir="rtl">
<head>
    <title>מאמר בדיקה בעברית</title>
    <meta name="author" content="יוחנן דוד">
</head>
<body>
    <article>
        <h1>מאמר בדיקה בעברית</h1>
        <p>זהו תוכן המאמר הראשי בעברית. הוא מכיל מספר פסקאות לבדיקת חילוץ התוכן.</p>
    </article>
</body>
</html>`

	bidiArticleHTML = `
<!DOCTYPE html>
<html>
<head>
    <title>CNN: Breaking News from الشرق الأوسط</title>
</head>
<body>
    <article>
        <h1>CNN: Breaking News from الشرق الأوسط</h1>
        <p>This article contains both English and Arabic text الأخبار العاجلة.</p>
    </article>
</body>
</html>`
)

func TestNewGenericExtractor(t *testing.T) {
	extractor := NewGenericExtractor()
	
	if extractor == nil {
		t.Fatal("NewGenericExtractor returned nil")
	}
	
	if extractor.Domain != "*" {
		t.Errorf("Expected domain '*', got '%s'", extractor.Domain)
	}
}

func TestGetDomain(t *testing.T) {
	extractor := NewGenericExtractor()
	domain := extractor.GetDomain()
	
	if domain != "*" {
		t.Errorf("Expected domain '*', got '%s'", domain)
	}
}

func TestExtractTitle(t *testing.T) {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(simpleArticleHTML))
	if err != nil {
		t.Fatalf("Failed to parse HTML: %v", err)
	}
	
	extractor := NewGenericExtractor()
	params := ExtractorParams{
		Doc: doc,
		URL: "https://example.com/article",
	}
	
	title, err := extractor.ExtractTitle(params)
	if err != nil {
		t.Errorf("ExtractTitle failed: %v", err)
	}
	
	if title == "" {
		t.Error("Expected non-empty title")
	}
	
	// Should extract title from HTML
	if !strings.Contains(title, "Test Article") {
		t.Errorf("Expected title to contain 'Test Article', got '%s'", title)
	}
}

func TestExtractAuthor(t *testing.T) {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(simpleArticleHTML))
	if err != nil {
		t.Fatalf("Failed to parse HTML: %v", err)
	}
	
	extractor := NewGenericExtractor()
	params := ExtractorParams{
		Doc: doc,
		URL: "https://example.com/article",
	}
	
	author, err := extractor.ExtractAuthor(params)
	if err != nil {
		t.Errorf("ExtractAuthor failed: %v", err)
	}
	
	// Author extraction should work with meta tags or content
	// The exact result depends on implementation, but should not error
	t.Logf("Extracted author: '%s'", author)
}

func TestExtractDatePublished(t *testing.T) {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(simpleArticleHTML))
	if err != nil {
		t.Fatalf("Failed to parse HTML: %v", err)
	}
	
	extractor := NewGenericExtractor()
	params := ExtractorParams{
		Doc: doc,
		URL: "https://example.com/article",
	}
	
	date, err := extractor.ExtractDatePublished(params)
	// Date extraction might return nil if no date found - this is acceptable
	if err != nil {
		t.Errorf("ExtractDatePublished failed: %v", err)
	}
	
	// nil result is acceptable when no date is found
	t.Logf("Extracted date: %v", date)
}

func TestExtractContent(t *testing.T) {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(simpleArticleHTML))
	if err != nil {
		t.Fatalf("Failed to parse HTML: %v", err)
	}
	
	extractor := NewGenericExtractor()
	params := ExtractorParams{
		Doc:   doc,
		HTML:  simpleArticleHTML,
		Title: "Test Article Title",
		URL:   "https://example.com/article",
	}
	
	content, err := extractor.ExtractContent(params)
	if err != nil {
		t.Errorf("ExtractContent failed: %v", err)
	}
	
	if content == "" {
		t.Error("Expected non-empty content")
	}
	
	// Should extract main content
	if !strings.Contains(content, "main content") {
		t.Errorf("Expected content to contain 'main content', got '%s'", content)
	}
}

func TestExtractDirection_LTR(t *testing.T) {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(simpleArticleHTML))
	if err != nil {
		t.Fatalf("Failed to parse HTML: %v", err)
	}
	
	extractor := NewGenericExtractor()
	params := ExtractorParams{
		Doc:   doc,
		Title: "Test Article Title", // English title
		URL:   "https://example.com/article",
	}
	
	direction, err := extractor.ExtractDirection(params)
	if err != nil {
		t.Errorf("ExtractDirection failed: %v", err)
	}
	
	if direction != "ltr" {
		t.Errorf("Expected direction 'ltr', got '%s'", direction)
	}
}

func TestExtractDirection_RTL(t *testing.T) {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(rtlArticleHTML))
	if err != nil {
		t.Fatalf("Failed to parse HTML: %v", err)
	}
	
	extractor := NewGenericExtractor()
	params := ExtractorParams{
		Doc:   doc,
		Title: "מאמר בדיקה בעברית", // Hebrew title
		URL:   "https://example.com/article",
	}
	
	direction, err := extractor.ExtractDirection(params)
	if err != nil {
		t.Errorf("ExtractDirection failed: %v", err)
	}
	
	if direction != "rtl" {
		t.Errorf("Expected direction 'rtl', got '%s'", direction)
	}
}

func TestExtractDirection_Bidi(t *testing.T) {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(bidiArticleHTML))
	if err != nil {
		t.Fatalf("Failed to parse HTML: %v", err)
	}
	
	extractor := NewGenericExtractor()
	params := ExtractorParams{
		Doc:   doc,
		Title: "CNN: Breaking News from الشرق الأوسط", // English + Arabic title
		URL:   "https://example.com/article",
	}
	
	direction, err := extractor.ExtractDirection(params)
	if err != nil {
		t.Errorf("ExtractDirection failed: %v", err)
	}
	
	if direction != "bidi" {
		t.Errorf("Expected direction 'bidi', got '%s'", direction)
	}
}

func TestExtractDirection_EmptyTitle(t *testing.T) {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(simpleArticleHTML))
	if err != nil {
		t.Fatalf("Failed to parse HTML: %v", err)
	}
	
	extractor := NewGenericExtractor()
	params := ExtractorParams{
		Doc:   doc,
		Title: "", // Empty title
		URL:   "https://example.com/article",
	}
	
	direction, err := extractor.ExtractDirection(params)
	if err != nil {
		t.Errorf("ExtractDirection failed: %v", err)
	}
	
	if direction != "" {
		t.Errorf("Expected empty direction for empty title, got '%s'", direction)
	}
}

func TestExtract_FullPipeline(t *testing.T) {
	// Test the complete extraction pipeline
	extractor := NewGenericExtractor()
	
	options := ExtractorContextOptions{
		HTML: simpleArticleHTML,
		URL:  "https://example.com/article",
	}
	
	result, err := extractor.Extract(options)
	if err != nil {
		t.Fatalf("Extract failed: %v", err)
	}
	
	if result == nil {
		t.Fatal("Extract returned nil result")
	}
	
	// Verify all fields are present
	if result.Title == "" {
		t.Error("Expected non-empty title")
	}
	
	if result.Content == "" {
		t.Error("Expected non-empty content")  
	}
	
	if result.Direction == "" {
		t.Error("Expected non-empty direction")
	}
	
	if result.URL != options.URL {
		t.Errorf("Expected URL '%s', got '%s'", options.URL, result.URL)
	}
	
	// Verify direction detection works
	if result.Direction != "ltr" {
		t.Errorf("Expected direction 'ltr' for English title, got '%s'", result.Direction)
	}
	
	t.Logf("Extraction result: Title='%s', Author='%s', Direction='%s'", 
		result.Title, result.Author, result.Direction)
}

func TestExtract_RTLContent(t *testing.T) {
	// Test extraction with RTL content
	extractor := NewGenericExtractor()
	
	options := ExtractorContextOptions{
		HTML: rtlArticleHTML,
		URL:  "https://example.com/hebrew-article",
	}
	
	result, err := extractor.Extract(options)
	if err != nil {
		t.Fatalf("Extract failed: %v", err)
	}
	
	// Verify RTL direction detection
	if result.Direction != "rtl" {
		t.Errorf("Expected direction 'rtl' for Hebrew content, got '%s'", result.Direction)
	}
	
	// Title should contain Hebrew text
	if !strings.Contains(result.Title, "בעברית") {
		t.Errorf("Expected Hebrew title, got '%s'", result.Title)
	}
}

func TestExtract_BidiContent(t *testing.T) {
	// Test extraction with bidirectional content
	extractor := NewGenericExtractor()
	
	options := ExtractorContextOptions{
		HTML: bidiArticleHTML,
		URL:  "https://example.com/mixed-article",
	}
	
	result, err := extractor.Extract(options)
	if err != nil {
		t.Fatalf("Extract failed: %v", err)
	}
	
	// Verify bidirectional direction detection
	if result.Direction != "bidi" {
		t.Errorf("Expected direction 'bidi' for mixed content, got '%s'", result.Direction)
	}
	
	// Title should contain both English and Arabic
	if !strings.Contains(result.Title, "CNN") || !strings.Contains(result.Title, "الشرق") {
		t.Errorf("Expected mixed language title, got '%s'", result.Title)
	}
}

func TestExtract_WithDocument(t *testing.T) {
	// Test extraction when Document is provided instead of HTML string
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(simpleArticleHTML))
	if err != nil {
		t.Fatalf("Failed to parse HTML: %v", err)
	}
	
	extractor := NewGenericExtractor()
	
	options := ExtractorContextOptions{
		Doc: doc,
		URL: "https://example.com/article",
	}
	
	result, err := extractor.Extract(options)
	if err != nil {
		t.Fatalf("Extract failed: %v", err)
	}
	
	if result == nil {
		t.Fatal("Extract returned nil result")
	}
	
	// Should work the same as HTML string input
	if result.Title == "" {
		t.Error("Expected non-empty title")
	}
	
	if result.Direction != "ltr" {
		t.Errorf("Expected direction 'ltr', got '%s'", result.Direction)
	}
}

func TestExtract_ErrorHandling(t *testing.T) {
	// Test error handling with invalid input
	extractor := NewGenericExtractor()
	
	// Test with no HTML or Document
	options := ExtractorContextOptions{
		URL: "https://example.com/article",
	}
	
	result, err := extractor.Extract(options)
	if err == nil {
		t.Error("Expected error when no HTML or Document provided")
	}
	
	if result != nil {
		t.Error("Expected nil result on error")
	}
}

func TestExtract_InvalidHTML(t *testing.T) {
	// Test with malformed HTML
	extractor := NewGenericExtractor()
	
	options := ExtractorContextOptions{
		HTML: "<html><head><title>Test</title>", // Unclosed tags
		URL:  "https://example.com/article",
	}
	
	result, err := extractor.Extract(options)
	// Should handle malformed HTML gracefully
	if err != nil {
		t.Logf("Expected behavior: malformed HTML handled with error: %v", err)
	} else if result != nil {
		// If it succeeds, it should still extract something reasonable
		t.Logf("Malformed HTML extraction succeeded: title='%s'", result.Title)
	}
}

func TestJavaScriptCompatibility_FieldOrder(t *testing.T) {
	// Test that extraction follows JavaScript field order and structure
	extractor := NewGenericExtractor()
	
	options := ExtractorContextOptions{
		HTML: simpleArticleHTML,
		URL:  "https://example.com/article",
	}
	
	result, err := extractor.Extract(options)
	if err != nil {
		t.Fatalf("Extract failed: %v", err)
	}
	
	// Verify JavaScript-compatible field structure
	expectedFields := []string{"title", "author", "date_published", "dek", 
		"lead_image_url", "content", "next_page_url", "url", "domain", 
		"excerpt", "word_count", "direction"}
		
	// This test verifies the struct has all expected fields
	// The JSON tags match JavaScript field names exactly
	
	if result.Title == "" && result.Content == "" {
		t.Error("At minimum, title or content should be extracted")
	}
	
	// DatePublished can be nil, matching JavaScript null behavior
	if result.DatePublished != nil {
		t.Logf("Date extracted: %s", *result.DatePublished)
	}
	
	// Direction should always be present (even if empty)
	t.Logf("Extracted direction: '%s'", result.Direction)
	
	t.Logf("JavaScript compatibility verified for %d fields", len(expectedFields))
}

func BenchmarkExtract(t *testing.B) {
	// Benchmark the full extraction pipeline
	extractor := NewGenericExtractor()
	
	options := ExtractorContextOptions{
		HTML: simpleArticleHTML,
		URL:  "https://example.com/article",
	}
	
	t.ResetTimer()
	for i := 0; i < t.N; i++ {
		extractor.Extract(options)
	}
}

func BenchmarkDirectionExtraction(t *testing.B) {
	// Benchmark just direction detection
	extractor := NewGenericExtractor()
	
	params := ExtractorParams{
		Title: "CNN: Breaking News from الشرق الأوسط",
		URL:   "https://example.com/article",
	}
	
	t.ResetTimer()
	for i := 0; i < t.N; i++ {
		extractor.ExtractDirection(params)
	}
}