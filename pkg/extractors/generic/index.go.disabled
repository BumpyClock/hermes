// ABOUTME: Generic extractor registry that orchestrates all field extraction with JavaScript compatibility
// ABOUTME: Central registry system that acts as fallback extractor for all domains matching JavaScript index.js

package generic

import (
	"errors"
	"fmt"
	"strings"

	"github.com/PuerkitoBio/goquery"
)

// ExtractorResult represents the complete extraction result 
// Matches JavaScript GenericExtractor.extract() return structure exactly
type ExtractorResult struct {
	Title           string      `json:"title"`
	Author          string      `json:"author"`
	DatePublished   *string     `json:"date_published"` // Pointer to match JavaScript null behavior
	Dek             string      `json:"dek"`
	LeadImageURL    string      `json:"lead_image_url"`
	Content         string      `json:"content"`
	NextPageURL     string      `json:"next_page_url"`
	URL             string      `json:"url"`
	Domain          string      `json:"domain"`
	Excerpt         string      `json:"excerpt"`
	WordCount       int         `json:"word_count"`
	Direction       string      `json:"direction"`
}

// ExtractorContextOptions holds extraction context and options
// Matches JavaScript function signature patterns
type ExtractorContextOptions struct {
	Doc     *goquery.Document
	HTML    string
	Title   string    // Context passed from title extractor
	Content string    // Context passed from content extractor  
	URL     string
}

// GenericExtractor represents the generic extraction registry
// Direct port of JavaScript GenericExtractor object
type GenericExtractor struct {
	Domain string // Always "*" for generic extractor
}

// NewGenericExtractor creates the generic extractor registry
func NewGenericExtractor() *GenericExtractor {
	return &GenericExtractor{
		Domain: "*", // Matches JavaScript: domain: '*'
	}
}

// ExtractTitle extracts article title using generic title extraction
// Matches JavaScript: title: GenericTitleExtractor.extract
func (g *GenericExtractor) ExtractTitle(params ExtractorParams) (string, error) {
	return ExtractTitle(params.Doc, params.URL)
}

// ExtractDatePublished extracts publication date using generic date extraction  
// Matches JavaScript: date_published: GenericDatePublishedExtractor.extract
func (g *GenericExtractor) ExtractDatePublished(params ExtractorParams) (*string, error) {
	date, err := ExtractDatePublished(params.Doc, params.URL)
	if err != nil {
		return nil, nil // Return nil on error to match JavaScript behavior
	}
	if date == "" {
		return nil, nil // Return nil for empty dates to match JavaScript null
	}
	return &date, nil
}

// ExtractAuthor extracts author information using generic author extraction
// Matches JavaScript: author: GenericAuthorExtractor.extract  
func (g *GenericExtractor) ExtractAuthor(params ExtractorParams) (string, error) {
	return ExtractAuthor(params.Doc, params.URL)
}

// ExtractContent extracts main content using generic content extraction
// Matches JavaScript: content: GenericContentExtractor.extract.bind(GenericContentExtractor)
func (g *GenericExtractor) ExtractContent(params ExtractorParams) (string, error) {
	extractor := NewGenericContentExtractor()
	extractorParams := ExtractorParams{
		Doc:   params.Doc,
		HTML:  params.HTML,
		Title: params.Title, // Pass title context
		URL:   params.URL,
	}
	return extractor.Extract(extractorParams)
}

// ExtractLeadImageURL extracts lead image using generic image extraction  
// Matches JavaScript: lead_image_url: GenericLeadImageUrlExtractor.extract
func (g *GenericExtractor) ExtractLeadImageURL(params ExtractorParams) (string, error) {
	extractorParams := ExtractorParams{
		Doc:     params.Doc,
		HTML:    params.HTML,
		Title:   params.Title,
		URL:     params.URL,
		Content: params.Content, // Context from content extractor
	}
	return ExtractLeadImageURL(extractorParams)
}

// ExtractDek extracts subtitle/description using generic dek extraction
// Matches JavaScript: dek: GenericDekExtractor.extract
func (g *GenericExtractor) ExtractDek(params ExtractorParams) (string, error) {
	extractorParams := ExtractorParams{
		Doc:     params.Doc,
		HTML:    params.HTML,
		Title:   params.Title,
		URL:     params.URL, 
		Content: params.Content, // Context from content extractor
	}
	return ExtractDek(extractorParams)
}

// ExtractNextPageURL extracts pagination URL (placeholder implementation)
// Matches JavaScript: next_page_url: GenericNextPageUrlExtractor.extract  
func (g *GenericExtractor) ExtractNextPageURL(params ExtractorParams) (string, error) {
	// TODO: Implement next page URL extraction when next_page_url extractor is ported
	return "", nil
}

// ExtractExcerpt extracts content excerpt (placeholder implementation)
// Matches JavaScript: excerpt: GenericExcerptExtractor.extract
func (g *GenericExtractor) ExtractExcerpt(params ExtractorParams) (string, error) {
	// TODO: Implement excerpt extraction when excerpt extractor is ported
	return "", nil
}

// ExtractWordCount counts words in content (placeholder implementation)
// Matches JavaScript: word_count: GenericWordCountExtractor.extract
func (g *GenericExtractor) ExtractWordCount(params ExtractorParams) (int, error) {
	// TODO: Implement word count extraction when word_count extractor is ported
	return 0, nil
}

// ExtractDirection extracts text direction from title
// Matches JavaScript: direction: ({ title }) => stringDirection.getDirection(title)
func (g *GenericExtractor) ExtractDirection(params ExtractorParams) (string, error) {
	return DirectionExtractor(params)
}

// ExtractURLAndDomain extracts URL and domain information (placeholder implementation)
// Matches JavaScript: url_and_domain: GenericUrlExtractor.extract  
func (g *GenericExtractor) ExtractURLAndDomain(params ExtractorParams) (string, string, error) {
	// TODO: Implement URL/domain extraction when url extractor is ported
	return params.URL, "", nil
}

// Extract orchestrates all field extraction and returns complete result
// Direct port of JavaScript GenericExtractor.extract() method
func (g *GenericExtractor) Extract(options ExtractorContextOptions) (*ExtractorResult, error) {
	// Validate input - match JavaScript parameter handling
	if options.Doc == nil && options.HTML == "" {
		return nil, errors.New("either Doc or HTML must be provided")
	}
	
	// Load HTML with goquery if needed - matches JavaScript cheerio.load() behavior
	doc := options.Doc
	if doc == nil && options.HTML != "" {
		var err error
		doc, err = goquery.NewDocumentFromReader(strings.NewReader(options.HTML))
		if err != nil {
			return nil, fmt.Errorf("failed to parse HTML: %w", err)
		}
	}
	
	// Create base extractor parameters
	baseParams := ExtractorParams{
		Doc:  doc,
		HTML: options.HTML,
		URL:  options.URL,
	}
	
	// Extract title first - matches JavaScript execution order
	// const title = this.title(options);
	title, err := g.ExtractTitle(baseParams)
	if err != nil {
		title = "" // Continue on error to match JavaScript behavior
	}
	
	// Update params with title context
	titleParams := baseParams
	titleParams.Title = title
	
	// Extract date published - matches JavaScript execution order  
	// const date_published = this.date_published(options);
	datePublished, err := g.ExtractDatePublished(titleParams)
	if err != nil {
		datePublished = nil // Continue on error
	}
	
	// Extract author - matches JavaScript execution order
	// const author = this.author(options);
	author, err := g.ExtractAuthor(titleParams)
	if err != nil {
		author = "" // Continue on error
	}
	
	// Extract content with title context - matches JavaScript execution order
	// const content = this.content({ ...options, title });  
	content, err := g.ExtractContent(titleParams)
	if err != nil {
		content = "" // Continue on error
	}
	
	// Update params with content context
	contentParams := titleParams
	contentParams.Content = content
	
	// Extract lead image with content context - matches JavaScript execution order
	// const lead_image_url = this.lead_image_url({ ...options, content });
	leadImageURL, err := g.ExtractLeadImageURL(contentParams)
	if err != nil {
		leadImageURL = "" // Continue on error
	}
	
	// Extract dek with content context - matches JavaScript execution order
	// const dek = this.dek({ ...options, content });
	dek, err := g.ExtractDek(contentParams)  
	if err != nil {
		dek = "" // Continue on error
	}
	
	// Extract remaining fields - matches JavaScript execution order
	nextPageURL, err := g.ExtractNextPageURL(contentParams)
	if err != nil {
		nextPageURL = ""
	}
	
	excerpt, err := g.ExtractExcerpt(contentParams)
	if err != nil {
		excerpt = ""
	}
	
	wordCount, err := g.ExtractWordCount(contentParams)
	if err != nil {
		wordCount = 0
	}
	
	// Extract direction from title - matches JavaScript execution order
	// const direction = this.direction({ title });
	direction, err := g.ExtractDirection(titleParams)
	if err != nil {
		direction = "" // Continue on error
	}
	
	// Extract URL and domain - matches JavaScript execution order
	// const { url, domain } = this.url_and_domain(options);
	url, domain, err := g.ExtractURLAndDomain(titleParams)
	if err != nil {
		url = options.URL
		domain = ""
	}
	
	// Return complete result matching JavaScript structure exactly
	// Matches JavaScript return object field order and types
	return &ExtractorResult{
		Title:         title,
		Author:        author,
		DatePublished: datePublished, // Can be nil to match JavaScript null
		Dek:           dek,
		LeadImageURL:  leadImageURL,
		Content:       content,
		NextPageURL:   nextPageURL,
		URL:           url,
		Domain:        domain,
		Excerpt:       excerpt,
		WordCount:     wordCount,
		Direction:     direction,
	}, nil
}

// GetDomain returns the domain this extractor handles
// Matches JavaScript extractor interface
func (g *GenericExtractor) GetDomain() string {
	return g.Domain
}