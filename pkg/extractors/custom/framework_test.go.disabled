// ABOUTME: Comprehensive test suite for custom extractor framework with JavaScript compatibility verification
// ABOUTME: Tests all framework components: types, selectors, transforms, registry, and orchestration

package custom

import (
	"fmt"
	"strings"
	"testing"

	"github.com/PuerkitoBio/goquery"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Test HTML for framework testing
const testHTML = `
<!DOCTYPE html>
<html>
<head>
	<meta name="og:title" content="Test Article Title">
	<meta name="author" content="Test Author">
	<meta name="article:published_time" content="2023-01-01T00:00:00Z">
	<meta name="og:image" content="https://example.com/image.jpg">
	<meta name="al:ios:app_name" content="Medium">
	<meta name="generator" content="blogger">
</head>
<body>
	<article>
		<h1>Main Article Title</h1>
		<p class="byline">By Test Author</p>
		<div class="content">
			<p>This is the main article content.</p>
			<img src="small.jpg" width="50" alt="Small image">
			<img src="large.jpg" width="200" alt="Large image">
			<figure>
				<img src="figure-img.jpg" alt="Figure image">
				<figcaption>Figure caption</figcaption>
				<iframe data-thumbnail="https://i.embed.ly/.../url=https://i.ytimg.com/vi/abc123/"></iframe>
			</figure>
			<span class="drop-cap">T</span>
			<svg>Icon</svg>
		</div>
	</article>
</body>
</html>`

// Test CustomExtractor types and interfaces
func TestCustomExtractorTypes(t *testing.T) {
	t.Run("CustomExtractor Creation", func(t *testing.T) {
		extractor := &CustomExtractor{
			Domain: "example.com",
			Title: &FieldExtractor{
				Selectors:      []interface{}{"h1", []interface{}{"meta[name=\"og:title\"]", "content"}},
				DefaultCleaner: true,
			},
			Content: &ContentExtractor{
				FieldExtractor: &FieldExtractor{
					Selectors: []interface{}{"article"},
				},
				Clean: []string{"svg"},
				Transforms: map[string]TransformFunction{
					"img": &FunctionTransform{
						Fn: func(selection *goquery.Selection) error {
							return RemoveSmallImages(selection, 100)
						},
					},
				},
			},
		}
		
		assert.Equal(t, "example.com", extractor.Domain)
		assert.NotNil(t, extractor.Title)
		assert.Equal(t, 2, len(extractor.Title.Selectors))
		assert.True(t, extractor.Title.DefaultCleaner)
		assert.NotNil(t, extractor.Content)
		assert.Equal(t, 1, len(extractor.Content.Clean))
		assert.Equal(t, 1, len(extractor.Content.Transforms))
	})
	
	t.Run("StringTransform", func(t *testing.T) {
		doc, err := goquery.NewDocumentFromReader(strings.NewReader("<div><noscript>content</noscript></div>"))
		require.NoError(t, err)
		
		transform := &StringTransform{TargetTag: "div"}
		selection := doc.Find("noscript")
		require.Equal(t, 1, selection.Length())
		
		err = transform.Transform(selection)
		assert.NoError(t, err)
	})
	
	t.Run("FunctionTransform", func(t *testing.T) {
		doc, err := goquery.NewDocumentFromReader(strings.NewReader(testHTML))
		require.NoError(t, err)
		
		transform := &FunctionTransform{
			Fn: func(selection *goquery.Selection) error {
				return RemoveSmallImages(selection, 100)
			},
		}
		
		images := doc.Find("img")
		initialCount := images.Length()
		
		err = transform.Transform(images)
		assert.NoError(t, err)
		
		// Should have fewer images after removing small ones
		remainingImages := doc.Find("img")
		assert.True(t, remainingImages.Length() < initialCount)
	})
}

// Test ExtractorRegistry functionality
func TestExtractorRegistry(t *testing.T) {
	t.Run("Registry Creation", func(t *testing.T) {
		registry := NewExtractorRegistry()
		assert.NotNil(t, registry)
		assert.Equal(t, 0, registry.Count())
	})
	
	t.Run("Register and Retrieve", func(t *testing.T) {
		registry := NewExtractorRegistry()
		
		extractor := &CustomExtractor{
			Domain:           "example.com",
			SupportedDomains: []string{"www.example.com", "blog.example.com"},
		}
		
		registry.Register(extractor)
		
		// Test primary domain
		retrieved, found := registry.GetByDomain("example.com")
		assert.True(t, found)
		assert.Equal(t, "example.com", retrieved.Domain)
		
		// Test supported domains
		retrieved, found = registry.GetByDomain("www.example.com")
		assert.True(t, found)
		assert.Equal(t, "example.com", retrieved.Domain)
		
		retrieved, found = registry.GetByDomain("blog.example.com")
		assert.True(t, found)
		assert.Equal(t, "example.com", retrieved.Domain)
		
		// Test non-existent domain
		_, found = registry.GetByDomain("nonexistent.com")
		assert.False(t, found)
		
		// Test count
		assert.Equal(t, 1, registry.Count())
	})
	
	t.Run("HTML Detection", func(t *testing.T) {
		registry := NewExtractorRegistry()
		
		mediumExtractor := &CustomExtractor{Domain: "medium.com"}
		bloggerExtractor := &CustomExtractor{Domain: "blogspot.com"}
		
		registry.RegisterHTMLDetector("meta[name=\"al:ios:app_name\"][content=\"Medium\"]", mediumExtractor)
		registry.RegisterHTMLDetector("meta[name=\"generator\"][content=\"blogger\"]", bloggerExtractor)
		
		// Test Medium detection
		mediumHTML := `<html><head><meta name="al:ios:app_name" content="Medium"></head></html>`
		doc, err := goquery.NewDocumentFromReader(strings.NewReader(mediumHTML))
		require.NoError(t, err)
		
		detected := registry.GetByHTML(doc)
		assert.NotNil(t, detected)
		assert.Equal(t, "medium.com", detected.Domain)
		
		// Test Blogger detection  
		bloggerHTML := `<html><head><meta name="generator" content="blogger"></head></html>`
		doc, err = goquery.NewDocumentFromReader(strings.NewReader(bloggerHTML))
		require.NoError(t, err)
		
		detected = registry.GetByHTML(doc)
		assert.NotNil(t, detected)
		assert.Equal(t, "blogspot.com", detected.Domain)
		
		// Test no detection
		plainHTML := `<html><head><title>Plain HTML</title></head></html>`
		doc, err = goquery.NewDocumentFromReader(strings.NewReader(plainHTML))
		require.NoError(t, err)
		
		detected = registry.GetByHTML(doc)
		assert.Nil(t, detected)
	})
}

// Test SelectorProcessor functionality
func TestSelectorProcessor(t *testing.T) {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(testHTML))
	require.NoError(t, err)
	
	processor := NewSelectorProcessor(doc, "https://example.com")
	
	t.Run("Simple Selector", func(t *testing.T) {
		extractor := &FieldExtractor{
			Selectors: []interface{}{"h1"},
		}
		
		result, err := processor.ExtractField("title", extractor, ExtractorOptions{})
		assert.NoError(t, err)
		assert.Equal(t, "Main Article Title", result)
	})
	
	t.Run("Attribute Selector", func(t *testing.T) {
		extractor := &FieldExtractor{
			Selectors: []interface{}{[]interface{}{"meta[name=\"og:title\"]", "content"}},
		}
		
		result, err := processor.ExtractField("title", extractor, ExtractorOptions{})
		assert.NoError(t, err)
		assert.Equal(t, "Test Article Title", result)
	})
	
	t.Run("Multiple Selectors Fallback", func(t *testing.T) {
		extractor := &FieldExtractor{
			Selectors: []interface{}{"h2", "h1"}, // h2 doesn't exist, should fallback to h1
		}
		
		result, err := processor.ExtractField("title", extractor, ExtractorOptions{})
		assert.NoError(t, err)
		assert.Equal(t, "Main Article Title", result)
	})
	
	t.Run("Extended Types", func(t *testing.T) {
		extend := map[string]*FieldExtractor{
			"custom_field": {
				Selectors: []interface{}{".byline"},
			},
		}
		
		results := processor.ExtractExtendedTypes(extend, ExtractorOptions{})
		assert.Contains(t, results, "custom_field")
		assert.Equal(t, "By Test Author", results["custom_field"])
	})
}

// Test Transform Functions
func TestTransformFunctions(t *testing.T) {
	t.Run("RemoveSmallImages", func(t *testing.T) {
		doc, err := goquery.NewDocumentFromReader(strings.NewReader(testHTML))
		require.NoError(t, err)
		
		images := doc.Find("img")
		initialCount := images.Length()
		
		err = RemoveSmallImages(images, 100)
		assert.NoError(t, err)
		
		// Should remove images with width < 100
		remainingImages := doc.Find("img")
		assert.True(t, remainingImages.Length() < initialCount)
	})
	
	t.Run("CleanFigures", func(t *testing.T) {
		doc, err := goquery.NewDocumentFromReader(strings.NewReader(testHTML))
		require.NoError(t, err)
		
		figures := doc.Find("figure")
		require.Equal(t, 1, figures.Length())
		
		err = CleanFigures(figures)
		assert.NoError(t, err)
		
		// Figure should now contain only img and figcaption
		figure := figures.First()
		assert.Equal(t, 1, figure.Find("img").Length())
		assert.Equal(t, 1, figure.Find("figcaption").Length())
		assert.Equal(t, 0, figure.Find("iframe").Length()) // Should be removed for non-YouTube
	})
	
	t.Run("AllowDropCap", func(t *testing.T) {
		doc, err := goquery.NewDocumentFromReader(strings.NewReader(testHTML))
		require.NoError(t, err)
		
		spans := doc.Find("span.drop-cap")
		require.Equal(t, 1, spans.Length())
		
		err = AllowDropCap(spans)
		assert.NoError(t, err)
	})
}

// Test JavaScript Compatibility
func TestJavaScriptCompatibility(t *testing.T) {
	t.Run("Medium Extractor Equivalent", func(t *testing.T) {
		// Create extractor matching JavaScript MediumExtractor
		mediumExtractor := &CustomExtractor{
			Domain: "medium.com",
			Title: &FieldExtractor{
				Selectors: []interface{}{"h1", []interface{}{"meta[name=\"og:title\"]", "content"}},
			},
			Author: &FieldExtractor{
				Selectors: []interface{}{[]interface{}{"meta[name=\"author\"]", "content"}},
			},
			Content: &ContentExtractor{
				FieldExtractor: &FieldExtractor{
					Selectors: []interface{}{"article"},
				},
				Clean: []string{"span a", "svg"},
				Transforms: map[string]TransformFunction{
					"img": &FunctionTransform{
						Fn: func(selection *goquery.Selection) error {
							return RemoveSmallImages(selection, 100)
						},
					},
				},
			},
			DatePublished: &FieldExtractor{
				Selectors: []interface{}{[]interface{}{"meta[name=\"article:published_time\"]", "content"}},
			},
			LeadImageURL: &FieldExtractor{
				Selectors: []interface{}{[]interface{}{"meta[name=\"og:image\"]", "content"}},
			},
		}
		
		// Test with HTML that should match
		doc, err := goquery.NewDocumentFromReader(strings.NewReader(testHTML))
		require.NoError(t, err)
		
		processor := NewSelectorProcessor(doc, "https://medium.com/test")
		
		// Test title extraction (should use meta tag over h1)
		title, err := processor.ExtractField("title", mediumExtractor.Title, ExtractorOptions{})
		assert.NoError(t, err)
		assert.Equal(t, "Test Article Title", title) // From meta tag
		
		// Test author extraction
		author, err := processor.ExtractField("author", mediumExtractor.Author, ExtractorOptions{})
		assert.NoError(t, err)
		assert.Equal(t, "Test Author", author)
		
		// Test date extraction
		date, err := processor.ExtractField("date_published", mediumExtractor.DatePublished, ExtractorOptions{})
		assert.NoError(t, err)
		assert.Equal(t, "2023-01-01T00:00:00Z", date)
		
		// Test lead image extraction
		image, err := processor.ExtractField("lead_image_url", mediumExtractor.LeadImageURL, ExtractorOptions{})
		assert.NoError(t, err)
		assert.Equal(t, "https://example.com/image.jpg", image)
	})
	
	t.Run("Selector Priority Matching JavaScript", func(t *testing.T) {
		// Test that selectors are tried in order, matching JavaScript behavior
		extractor := &FieldExtractor{
			Selectors: []interface{}{
				"h2",                                              // Doesn't exist
				[]interface{}{"meta[name=\"nonexistent\"]", "content"}, // Doesn't exist  
				"h1",                                              // Should match this
				[]interface{}{"meta[name=\"og:title\"]", "content"},     // Would also match but comes after
			},
		}
		
		doc, err := goquery.NewDocumentFromReader(strings.NewReader(testHTML))
		require.NoError(t, err)
		
		processor := NewSelectorProcessor(doc, "https://example.com")
		result, err := processor.ExtractField("title", extractor, ExtractorOptions{})
		assert.NoError(t, err)
		assert.Equal(t, "Main Article Title", result) // From h1, not meta tag
	})
}

// Test Registry Manager
func TestRegistryManager(t *testing.T) {
	t.Run("Thread Safety", func(t *testing.T) {
		manager := NewRegistryManager()
		
		// Test concurrent access
		done := make(chan bool)
		
		go func() {
			for i := 0; i < 100; i++ {
				extractor := &CustomExtractor{
					Domain: "test1.com",
				}
				manager.Register(extractor)
			}
			done <- true
		}()
		
		go func() {
			for i := 0; i < 100; i++ {
				manager.GetByDomain("test1.com")
			}
			done <- true
		}()
		
		<-done
		<-done
		
		count, _ := manager.Count()
		assert.Equal(t, 1, count) // Should have only one extractor despite 100 registrations
	})
	
	t.Run("Domain Mapping", func(t *testing.T) {
		manager := NewRegistryManager()
		
		extractor := &CustomExtractor{
			Domain:           "example.com",
			SupportedDomains: []string{"www.example.com", "blog.example.com"},
		}
		
		err := manager.Register(extractor)
		assert.NoError(t, err)
		
		// Test domain mapping
		mapping := manager.GetDomainMapping()
		assert.Equal(t, 3, len(mapping)) // Primary + 2 supported
		assert.Equal(t, extractor, mapping["example.com"])
		assert.Equal(t, extractor, mapping["www.example.com"])
		assert.Equal(t, extractor, mapping["blog.example.com"])
	})
}

// Benchmark tests
func BenchmarkSelectorProcessor(b *testing.B) {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(testHTML))
	require.NoError(b, err)
	
	processor := NewSelectorProcessor(doc, "https://example.com")
	extractor := &FieldExtractor{
		Selectors: []interface{}{"h1", []interface{}{"meta[name=\"og:title\"]", "content"}},
	}
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		processor.ExtractField("title", extractor, ExtractorOptions{})
	}
}

func BenchmarkRegistryLookup(b *testing.B) {
	manager := NewRegistryManager()
	
	// Register 100 extractors
	for i := 0; i < 100; i++ {
		extractor := &CustomExtractor{
			Domain: fmt.Sprintf("test%d.com", i),
		}
		manager.Register(extractor)
	}
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		manager.GetByDomain("test50.com")
	}
}