// ABOUTME: Integration test demonstrating complete custom extractor framework functionality
// ABOUTME: End-to-end testing of extractor selection, field extraction, transforms, and JavaScript compatibility

package custom

import (
	"fmt"
	"strings"
	"testing"

	"github.com/PuerkitoBio/goquery"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Complete test HTML simulating a real Medium article
const mediumTestHTML = `
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="al:ios:app_name" content="Medium">
	<meta name="author" content="Jane Smith">
	<meta name="og:title" content="The Future of AI: A Deep Dive">
	<meta name="article:published_time" content="2023-10-15T14:30:00Z">
	<meta name="og:image" content="https://miro.medium.com/max/1200/featured-image.jpg">
	<meta name="description" content="Exploring the latest developments in artificial intelligence">
	<title>The Future of AI: A Deep Dive | Medium</title>
</head>
<body>
	<article>
		<header>
			<h1>The Future of AI: A Deep Dive</h1>
			<div class="author-info">
				<span class="author">Jane Smith</span>
				<time datetime="2023-10-15T14:30:00Z">Oct 15, 2023</time>
			</div>
		</header>
		
		<section>
			<p>Artificial Intelligence is transforming our world at an unprecedented pace.</p>
			
			<figure>
				<img src="small-icon.jpg" width="24" alt="Small icon">
				<img src="main-diagram.jpg" width="800" alt="AI Architecture Diagram">
				<figcaption>Figure 1: AI Architecture Overview</figcaption>
				<iframe data-thumbnail="https://i.embed.ly/1/image?url=https://i.ytimg.com/vi/dQw4w9WgXcQ/maxresdefault.jpg&key=abc123"></iframe>
			</figure>
			
			<p><span class="drop-cap">M</span>achine learning algorithms continue to evolve.</p>
			
			<blockquote>
				"The best way to predict the future is to invent it." - Alan Kay
			</blockquote>
			
			<div class="code-block">
				<code>
					def future_ai():
						return "revolutionary"
				</code>
			</div>
			
			<ul>
				<li>Natural Language Processing</li>
				<li>Computer Vision</li>
				<li>Robotics</li>
			</ul>
			
			<!-- These elements should be removed by cleaning -->
			<span><a href="#share">Share</a></span>
			<svg viewBox="0 0 24 24"><path d="M12 2l3.09..."/></svg>
			
			<p>In conclusion, the future of AI holds immense possibilities for humanity.</p>
		</section>
	</article>
</body>
</html>`

// Blogger test HTML
const bloggerTestHTML = `
<!DOCTYPE html>
<html>
<head>
	<meta name="generator" content="blogger">
	<meta name="author" content="Tech Blogger">
	<meta property="og:title" content="My Tech Journey">
	<meta property="article:published_time" content="2023-09-20T10:15:00Z">
	<title>My Tech Journey - Tech Blog</title>
</head>
<body>
	<div class="post">
		<h1 class="post-title">My Tech Journey</h1>
		<div class="post-author">Tech Blogger</div>
		<div class="post-body">
			<p>Starting my career in technology was both exciting and challenging.</p>
			<p>Here are the key lessons I learned along the way.</p>
		</div>
		<div class="post-footer">
			<span>Posted in: Technology</span>
		</div>
	</div>
	<div class="blog-pager">
		<a href="/next">Next Post</a>
	</div>
</body>
</html>`

func TestCompleteFrameworkIntegration(t *testing.T) {
	t.Run("Medium Article Extraction", func(t *testing.T) {
		// Setup the complete Medium extractor
		mediumExtractor := createMediumExtractor()
		
		// Register with global registry
		GlobalRegistryManager.Clear()
		err := GlobalRegistryManager.Register(mediumExtractor)
		require.NoError(t, err)
		
		// Register HTML detector
		err = GlobalRegistryManager.RegisterHTMLDetector(
			"meta[name=\"al:ios:app_name\"][content=\"Medium\"]",
			mediumExtractor,
		)
		require.NoError(t, err)
		
		// Parse test HTML
		doc, err := goquery.NewDocumentFromReader(strings.NewReader(mediumTestHTML))
		require.NoError(t, err)
		
		// Test HTML-based detection
		detected := GlobalRegistryManager.GetByHTML(doc)
		assert.NotNil(t, detected)
		assert.Equal(t, "medium.com", detected.Domain)
		
		// Test complete field extraction
		processor := NewSelectorProcessor(doc, "https://medium.com/@jane/ai-future")
		
		// Extract title (should prefer meta tag)
		title, err := processor.ExtractField("title", mediumExtractor.Title, ExtractorOptions{})
		require.NoError(t, err)
		assert.Equal(t, "The Future of AI: A Deep Dive", title)
		
		// Extract author
		author, err := processor.ExtractField("author", mediumExtractor.Author, ExtractorOptions{})
		require.NoError(t, err)
		assert.Equal(t, "Jane Smith", author)
		
		// Extract date
		date, err := processor.ExtractField("date_published", mediumExtractor.DatePublished, ExtractorOptions{})
		require.NoError(t, err)
		assert.Equal(t, "2023-10-15T14:30:00Z", date)
		
		// Extract lead image
		image, err := processor.ExtractField("lead_image_url", mediumExtractor.LeadImageURL, ExtractorOptions{})
		require.NoError(t, err)
		assert.Equal(t, "https://miro.medium.com/max/1200/featured-image.jpg", image)
		
		// Extract and transform content
		opts := ExtractorOptions{
			ExtractHtml: true,
			URL:         "https://medium.com/@jane/ai-future",
		}
		content, err := processor.ExtractField("content", mediumExtractor.Content.FieldExtractor, opts)
		require.NoError(t, err)
		
		contentStr := content.(string)
		
		// Verify transforms were applied
		assert.NotContains(t, contentStr, "small-icon.jpg")     // Small images removed
		assert.Contains(t, contentStr, "main-diagram.jpg")      // Large images preserved
		assert.NotContains(t, contentStr, "<span><a")          // Clean selectors applied
		assert.NotContains(t, contentStr, "<svg")              // SVG elements removed
		assert.Contains(t, contentStr, "<blockquote>")         // Important content preserved
		assert.Contains(t, contentStr, "<code>")               // Code blocks preserved
		assert.Contains(t, contentStr, "<ul>")                 // Lists preserved
	})
	
	t.Run("Blogger Article Extraction", func(t *testing.T) {
		// Setup the complete Blogger extractor
		bloggerExtractor := createBloggerExtractor()
		
		// Register with global registry
		GlobalRegistryManager.Clear()
		err := GlobalRegistryManager.Register(bloggerExtractor)
		require.NoError(t, err)
		
		// Register HTML detector
		err = GlobalRegistryManager.RegisterHTMLDetector(
			"meta[name=\"generator\"][content=\"blogger\"]",
			bloggerExtractor,
		)
		require.NoError(t, err)
		
		// Parse test HTML
		doc, err := goquery.NewDocumentFromReader(strings.NewReader(bloggerTestHTML))
		require.NoError(t, err)
		
		// Test HTML-based detection
		detected := GlobalRegistryManager.GetByHTML(doc)
		assert.NotNil(t, detected)
		assert.Equal(t, "blogspot.com", detected.Domain)
		
		// Test field extraction
		processor := NewSelectorProcessor(doc, "https://techblog.blogspot.com/2023/09/my-journey.html")
		
		// Extract title
		title, err := processor.ExtractField("title", bloggerExtractor.Title, ExtractorOptions{})
		require.NoError(t, err)
		assert.Equal(t, "My Tech Journey", title)
		
		// Extract author
		author, err := processor.ExtractField("author", bloggerExtractor.Author, ExtractorOptions{})
		require.NoError(t, err)
		assert.Equal(t, "Tech Blogger", author)
		
		// Extract content with cleaning
		opts := ExtractorOptions{
			ExtractHtml: true,
			URL:         "https://techblog.blogspot.com/2023/09/my-journey.html",
		}
		content, err := processor.ExtractField("content", bloggerExtractor.Content.FieldExtractor, opts)
		require.NoError(t, err)
		
		contentStr := content.(string)
		
		// Verify cleaning was applied
		assert.NotContains(t, contentStr, "post-footer")  // Footer removed
		assert.NotContains(t, contentStr, "blog-pager")   // Pager removed
		assert.Contains(t, contentStr, "Starting my career") // Main content preserved
	})
	
	t.Run("Domain-based Extractor Selection", func(t *testing.T) {
		// Register multiple extractors
		GlobalRegistryManager.Clear()
		
		mediumExtractor := createMediumExtractor()
		bloggerExtractor := createBloggerExtractor()
		
		err := GlobalRegistryManager.Register(mediumExtractor)
		require.NoError(t, err)
		
		err = GlobalRegistryManager.Register(bloggerExtractor)
		require.NoError(t, err)
		
		// Test domain-based lookup
		extracted, found := GlobalRegistryManager.GetByDomain("medium.com")
		assert.True(t, found)
		assert.Equal(t, "medium.com", extracted.Domain)
		
		extracted, found = GlobalRegistryManager.GetByDomain("blogspot.com")
		assert.True(t, found)
		assert.Equal(t, "blogspot.com", extracted.Domain)
		
		// Test supported domains
		extracted, found = GlobalRegistryManager.GetByDomain("blogger.com")
		assert.True(t, found)
		assert.Equal(t, "blogspot.com", extracted.Domain) // Should map to blogspot.com
		
		// Test non-existent domain
		_, found = GlobalRegistryManager.GetByDomain("unknown.com")
		assert.False(t, found)
	})
	
	t.Run("Extended Types Extraction", func(t *testing.T) {
		// Create extractor with extended types
		extractor := &CustomExtractor{
			Domain: "example.com",
			Extend: map[string]*FieldExtractor{
				"reading_time": {
					Selectors: []interface{}{"meta[name=\"reading-time\"]"},
				},
				"tags": {
					Selectors:     []interface{}{".tag"},
					AllowMultiple: true,
				},
			},
		}
		
		// Test HTML with extended fields
		testHTML := `
		<html>
		<head><meta name="reading-time" content="5 min read"></head>
		<body>
			<div class="tag">AI</div>
			<div class="tag">Technology</div>
			<div class="tag">Future</div>
		</body>
		</html>`
		
		doc, err := goquery.NewDocumentFromReader(strings.NewReader(testHTML))
		require.NoError(t, err)
		
		processor := NewSelectorProcessor(doc, "https://example.com")
		
		// Extract extended types
		results := processor.ExtractExtendedTypes(extractor.Extend, ExtractorOptions{})
		
		assert.Contains(t, results, "reading_time")
		assert.Equal(t, "5 min read", results["reading_time"])
		
		assert.Contains(t, results, "tags")
		tags := results["tags"].([]string)
		assert.Equal(t, 3, len(tags))
		assert.Contains(t, tags, "AI")
		assert.Contains(t, tags, "Technology")
		assert.Contains(t, tags, "Future")
	})
}

func TestFrameworkPerformance(t *testing.T) {
	t.Run("Registry Performance", func(t *testing.T) {
		// Register 100 extractors to test performance
		GlobalRegistryManager.Clear()
		
		for i := 0; i < 100; i++ {
			extractor := &CustomExtractor{
				Domain: fmt.Sprintf("site%d.com", i),
				Title: &FieldExtractor{
					Selectors: []interface{}{"h1"},
				},
			}
			err := GlobalRegistryManager.Register(extractor)
			require.NoError(t, err)
		}
		
		// Verify all registered
		count, domainCount := GlobalRegistryManager.Count()
		assert.Equal(t, 100, count)
		assert.Equal(t, 100, domainCount)
		
		// Test lookup performance
		for i := 0; i < 100; i++ {
			domain := fmt.Sprintf("site%d.com", i)
			extracted, found := GlobalRegistryManager.GetByDomain(domain)
			assert.True(t, found)
			assert.Equal(t, domain, extracted.Domain)
		}
	})
}

// Helper functions to create test extractors

func createMediumExtractor() *CustomExtractor {
	return &CustomExtractor{
		Domain: "medium.com",
		Title: &FieldExtractor{
			Selectors:      []interface{}{"h1", []interface{}{"meta[name=\"og:title\"]", "content"}},
			DefaultCleaner: true,
		},
		Author: &FieldExtractor{
			Selectors:      []interface{}{[]interface{}{"meta[name=\"author\"]", "content"}},
			DefaultCleaner: true,
		},
		Content: &ContentExtractor{
			FieldExtractor: &FieldExtractor{
				Selectors:      []interface{}{"article"},
				DefaultCleaner: true,
			},
			Clean: []string{"span a", "svg"},
			Transforms: map[string]TransformFunction{
				"img": &FunctionTransform{
					Fn: func(selection *goquery.Selection) error {
						return RemoveSmallImages(selection, 100)
					},
				},
				"figure": &FunctionTransform{
					Fn: CleanFigures,
				},
				"iframe": &FunctionTransform{
					Fn: RewriteLazyYoutube,
				},
				"section span:first-of-type": &FunctionTransform{
					Fn: AllowDropCap,
				},
			},
		},
		DatePublished: &FieldExtractor{
			Selectors:      []interface{}{[]interface{}{"meta[name=\"article:published_time\"]", "content"}},
			DefaultCleaner: true,
		},
		LeadImageURL: &FieldExtractor{
			Selectors:      []interface{}{[]interface{}{"meta[name=\"og:image\"]", "content"}},
			DefaultCleaner: true,
		},
	}
}

func createBloggerExtractor() *CustomExtractor {
	return &CustomExtractor{
		Domain:           "blogspot.com",
		SupportedDomains: []string{"blogger.com"},
		Title: &FieldExtractor{
			Selectors:      []interface{}{".post-title", "h1", []interface{}{"meta[property=\"og:title\"]", "content"}},
			DefaultCleaner: true,
		},
		Author: &FieldExtractor{
			Selectors:      []interface{}{".post-author", []interface{}{"meta[name=\"author\"]", "content"}},
			DefaultCleaner: true,
		},
		Content: &ContentExtractor{
			FieldExtractor: &FieldExtractor{
				Selectors:      []interface{}{".post-body", ".entry-content"},
				DefaultCleaner: true,
			},
			Clean: []string{".post-footer", ".blog-pager"},
		},
		DatePublished: &FieldExtractor{
			Selectors:      []interface{}{[]interface{}{".published", "datetime"}, []interface{}{"meta[property=\"article:published_time\"]", "content"}},
			DefaultCleaner: true,
		},
	}
}

// Benchmark the complete framework
func BenchmarkCompleteFramework(b *testing.B) {
	// Setup
	GlobalRegistryManager.Clear()
	mediumExtractor := createMediumExtractor()
	err := GlobalRegistryManager.Register(mediumExtractor)
	require.NoError(b, err)
	
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(mediumTestHTML))
	require.NoError(b, err)
	
	processor := NewSelectorProcessor(doc, "https://medium.com/test")
	
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// Full extraction pipeline
		processor.ExtractField("title", mediumExtractor.Title, ExtractorOptions{})
		processor.ExtractField("author", mediumExtractor.Author, ExtractorOptions{})
		processor.ExtractField("content", mediumExtractor.Content.FieldExtractor, ExtractorOptions{ExtractHtml: true})
	}
}